---
title: "Assignment 5: Environmental equity, access to natural areas"
author: "Xiyu Zhang"
date: "June 18, 2023"
output: html_document
---

<!-- Please knit this right away! The additional information for (html and css)
are provided to help you build on your current R Markdown toolbox. You will not
be responsible for learning these additional tools at this point. -->

<!-- The head tag, <head>, is a container for metadata in an html document. 
We can use it to define styles and do lots of other cool things things. -->
<head>
<!-- The link tag, <link>, creates a relationship between this file and
an external source. Here, I'm linking font-awesome so I can include a 
couple of icons that I like (user-secret and user-circle) -->
<link 
  rel="stylesheet" 
  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<!-- Here I'm linking to a javascript file that will give us access to font awesome -->
  <script src="https://kit.fontawesome.com/03064bdd6c.js" crossorigin="anonymous"></script>
</head>
<!-- Note in the above that some html tags, like <head> need to be closed 
with </head>. Others, like <link> don't need a closing tag. -->

```{css, echo = FALSE}
/* We can use the body tag to change the default text size of the whole document. */
  
body {
  font-size: 18px
}

/* We can increase the space between our list items */
  
ul, li {
  padding-top: 0.25em;
}

pre {
  margin-top: 2em;
  margin-bottom: 2em;
}

/* I can add custom classes with a period symbol. */

.score {
  font-weight: bold;
  color: red;
  background-color: #ffff80;
}

/* I create an custom class for user secrets. Have a look at the area surrounding my spy icons below to see what this does. Also, do you notice any similarity to your ggPlot theme elements? */
  
.mysecret {
  border: 1px solid #999999;
  border-style: solid; 
  padding: 20px; 
  border-radius: 25px;
  margin-top: 15px;
  margin-bottom: 15px;
}

/* Here, I add a custom class for area surrounding the graded portions of this assignment.*/

.now_you {
  border-left: 8px solid #292093;
  background-color: #e6ffff;
  padding: 16px;
  margin-top: 15px;
  margin-bottom: 15px;
}

/* Here I will add some custom css on my font awesome icons*/
  
.fas {
  font-size:36px
}
  
.subscore {
  font-size: 14px;
  color: red;
}

/* I can modify a current class like the below. To see what this does,
have a look at where I am using block quotes in the document.*/
  
blockquote {
  font-size: 18px;
  border-left: 8px solid #292093;
  background-color: #e6ffff;
  padding-left: 16px;
  padding-right: 16px;
  margin-top: 15px;
  margin-bottom: 15px;
}

/* Accordion style */
.accordion {
  background-color: #e6f0ff;
  color: #000000;
  cursor: pointer;
  padding: 18px;
  width: 100%;
  border-style: solid;
  border-width: 2px;
  border-color: #ffffff;
  text-align: left;
  outline: none;
  font-size: 15px;
  transition: 0.4s;
}

.active, .accordion:hover {
  background-color: #80b3ff; 
  color: #ffffff;
  font-weight: bold;
}

.panel {
  padding: 0 18px;
  display: none;
  background-color: #eeffff;
  overflow: hidden;
}
```

<!-- Here is the setup for knitr. I had to include tidyverse so I could
include a tidyverse example with my Important warning statement below-->

```{r knitr_setup, include = FALSE}
options(knitr.table.format = "html")

knitr::opts_chunk$set(error = TRUE)

library(tidyverse)
```

<hr>

## Overview

<div class = "row">

<figure 
  style = 
    "float: right; 
    padding-left: 2em; 
    padding-bottom: 1em; padding-right: 0em; 
    width: 50%; 
    height: auto;">
  <img  
    src = "https://www.funinfairfaxva.com/wp-content/uploads/2015/03/Roosevelt-Island-boardwalk-trail.jpg"
    alt="Trail on Roosevelt Island">
  </img>
  <figcaption style = "font-size: 0.75em;">*A trail on DC's Roosevelt Island.*</figcaption>
</figure>

<div style = "padding-left: 1em;">

Free play in "nature" is expected to positively impact childhood development. In this assignment we will address the idea of *environmental equity* in Washington DC, specifically in regards to access to wild green spaces in the city. Socioeconomic status has been found to be a strong determinant of whether children have access to such spaces. 

In this exercise, you will use raster data and shapefiles to explore the distribution of forest in the city.
</div>

</div>

<!-- A div is a container for html. I assign it to the class "my secret that
we created above -->
<div class = "mysecret">
<!-- The i tag is commonly used to create italic text, but it can also be 
used to create icons -->
<i class="fas fa-user-secret"></i> When I create an R Markdown file to communicate a coding process, I usually work in a .R script file and copy-and-paste the code into the R Markdown document at the end.
</div>

<hr>

<span style = "color: red; font-size: 36px"><i class="fas fa-exclamation-triangle"></i> **Important**</span> 

To receive full credit for a given question, please ensure that the result you provide **only** answers the given question. For example, in the table below, if you were asked to determine the value in column `b` where column `a` is equal to "hello" you would provide the following code:

```{r example}
tibble(
  a = c('hello', 'world'),
  b = 1:2) %>% 
  filter(a == 'hello') %>% 
  pull(b)
```

<hr>

## Grading

The points allotted for each question are provided in highlighted red bold text (e.g., <span class = "score">[1.0]</span>) within the question itself. When applicable, total points for a question may represent the sum of individually graded components, which are provided in red text (e.g., <span class = "subscore">[1.0]</span>).

**Points may be deducted from each question's total:** 

* Use only functions other than those listed in "Functions that you may use in this assignment" [50%]
* Do not include any assignments other than those specified in the question [50%]
* Unless specified otherwise, each question must be answered in a single piped statement [50%]
* Include a comment at the start of each code block [25%]
* Include a comment for each line of code that modifies a dataset [10% per violation]
* Ensure that all code is properly indented [10% per violation]
* Ensure that your code follows modern coding conventions (see *Best practices in modern R coding*) [10% per violation]

*Note: The maximum deduction is the total points value for a given question*

You must ensure that your R Markdown document **runs out-of-the-box** -- in other words, the document will knit without error. Some tips for doing so:

* Do not maintain your project folder in a location that is backed up by an online directory (e.g., Dropbox, iCloud)
* Ensure that all file paths are equivalent to those in this document (e.g., in `source()` or `read_csv()`)
* Do not use `setwd()` in your code (***Never** use `setwd()`!*)
* If one of your code chunks contains an error, include `eval = FALSE` in the options for that chunk
* Prior to submission, clear all objects from your global environment prior to knitting your R Markdown document
<hr>


<div>
<button class="accordion">Functions that you may use in this assignment</button>
<div class="panel">

In this assignment, you may use **only** the following R functions (*Note: If you are unclear on what a given function does, use `?` to view the help file!*):

* base:: ::
* base::<-
* base::=
* base::==
* base::>=
* base::+
* base::$
* base::!
* base::~
* base::(
* base::)
* base::as.matrix
* base::c
* base::cut
* base::is.na
* base::library
* base::mean
* base::rm
* base::source
* dplyr::case_when
* dplyr::if_else
* dplyr::filter
* dplyr::group_by
* dplyr::mutate
* dplyr::pull
* dplyr::summarize
* dplyr::transmute
* forcats::fct_recode
* forcats::fct_relevel
* magrittr::%>%
* stringr::str_detect
* terra::classify
* terra::extract
* terra::rasterize
* tibble::tibble
* tibble::tribble
* tmap::tm_basemap
* tmap::tm_polygons
* tmap::tm_raster
* tmap::tm_shape
* tmap::tmap_mode
* tmap::tmap_options

*Note: The packages dplyr, ggplot2, magrittr, readr, rlang, and tibble are all part of the tidyverse and are loaded with `library(tidyverse)`.*

</div>
</div>

<hr>

## Getting started

Open R Studio. Please ensure that the Global Options for R Markdown are set to "Show output preview in Viewer Pane". This will allow you to view the knitted document (i.e., the html version of this file) right next to your code.

As always, please ensure that you are starting with a clean session. Please do the following before continuing:

* If there are any script files open in your source pane. Close them. If any of the file titles are blue, save them prior to closing.

* In the *Environment* tab of your **workspace pane**, ensure that your **global environment** is empty. If it is not, click the *broom* to remove all objects.

* In the *History* tab of your **workspace pane**, ensure that your history is empty. If it is not, click the *broom* to remove your history.

<div class = "now_you">
<i class="fas fa-user-circle"></i> 

<hr>

1\. <span class = "score">[0.5]</span> Save and knit this document:

* Replace my name in the YAML header with yours <span class = "subscore">[0.1]</span>
* Add the current date in the YAML header <span class = "subscore">[0.1]</span>
* Save the *.rmd* file in the **output** folder of your project as (*but replace my name with yours*): `assignment_6_Evans_Brian.rmd` <span class = "subscore">[0.3]</span>
</div>
<hr>

## The setup

**All** of my scripts start with a setup section where I load libraries, set session options, conduct initial data loading, and early processing steps.

<div class = "now_you">
<i class="fas fa-user-circle"></i> 
<hr>
2\. <span class = "score">[0.5]</span> Load the `sf`, `tmap`, and `tidyverse` libraries.

```{r question_2, results = 'hide', message = FALSE, warning = FALSE}

# Load libraries

library(sf)
library(tmap)
library(tidyverse)

```

3\. <span class = "score">[0.5]</span> Load the data from the source script `source_script_bird_mortality.R` <span class = "score">[0.25]</span> and set the tmap mode to "view" for the entire document <span class = "score">[0.25]</span>.

```{r question_3, results = 'hide', message = FALSE}

# Load data

source('scripts/source_script_bird_mortality.R')

# Set the tmap mode for the whole document

tmap_mode('view')

```

The code below is necessary due to a current bug and an issue during on-the-fly reprojections that occur under-the-hood in tmap. Please run it: 

```{r}
tmap::tmap_options(check.and.fix = TRUE)
```

We will not use the `birds` or `cicadas` files, so please run the code below to remove the objects from your global environment:

```{r, warning = FALSE}
rm(cicadas, birds)
```

4\. <span class = "score">[1.0]</span> Convert the `census` data to a `SpatRaster` object:

* <span class = "subscore">[0.5]</span> With the same resolution and extent as `rasters`;
* <span class = "subscore">[0.3]</span> With values based on the field `income`;
* <span class = "subscore">[0.1]</span> Assign the name `income_dc` to the resultant object;

```{r 4_a-c, results = FALSE}

# convert the census data to a SpatRaster object

income_dc <-
  terra::rasterize(
    
    # the name of the shapefile
    
    x = census, 
    
    # the name of the raster file being the base of the conversion
    
    y = rasters,
    
    # the field of interest is "income"
    
    field = 'income')

```

* <span class = "subscore">[0.1]</span> Remove `census` from your global environment:

```{r 4_d}

# remove census from global environment

rm(census)

```


5\. <span class = "score">[1.0]</span> The DC parks and recreation department seeks to create green space for children and adults alike. This dataset contains the field "woodland" to describe the type of park. Using `parks_and_rec`:

* <span class = "subscore">[0.2]</span> Subset DC parks to those where the values in `woodland` are not NA; 
* <span class = "subscore">[0.4]</span> Without using `if_else` or `case_when`, add a field called `park_type` in which you reclassify `woodland` into the values "Forested" (`woodland == "Y"`) and Not forested" (`woodland == "N"`) 
* <span class = "subscore">[0.2]</span> As parsimoniously as possible, subset the data to the columns objectid and `park_type`;
* <span class = "subscore">[0.1]</span> Assign to the global environment with the name `dc_parks`;

```{r 5_a-d, results = FALSE}

#  process data describing the park area in DC

dc_parks <-
  parks_and_rec %>% 
  
  # subset DC parks features to those "woodland" are not NA
  
  filter(!is.na(woodland)) %>% 
  
  # add a field to reclassify 'woodland'
  
  mutate(park_type = woodland %>% 
           
           # recode the previous values as the new values
           
           fct_recode(Forested = 'Y',
                      `Not forested` = 'N')) %>% 
  
  # subset data to 'objectid' and 'park_type' columns
  
  select(objectid, park_type)

```

* <span class = "subscore">[0.1]</span> Remove `parks_and_rec` from your global environment:

```{r 5_e}

# remove 'park_and_rec'

rm(parks_and_rec)

```

6\. <span class = "score">[1.0]</span> Using `nlcd_key`, create a reclass matrix where:

* <span class = "subscore">[0.2]</span> Water is given the value NA;
* <span class = "subscore">[0.15]</span> Developed land cover classes are mapped to the value 1;
* <span class = "subscore">[0.15]</span> Forest land cover classes are mapped to the value 2;
* <span class = "subscore">[0.15]</span> All other classes are mapped to the value 3;
* <span class = "subscore">[0.15]</span> The resultant object is a matrix;
* <span class = "subscore">[0.1]</span> The object is assigned to the global environment with the name `rcl_nlcd`;

```{r 6_a-f, results = FALSE}

# create a reclass matrix

rcl_nlcd <-
  
  # using nlcd_key
  
  nlcd_key %>% 
  
  # apply transmute to create new columns and to discard the old ones
  
  transmute(
    
    # 'is' column represents the current categories in the nlcd raster
    
    is = id,
    
    # 'becomes' column is the new value. 
    # 'case_when' is used for multiple classes
    
    becomes = case_when(
      
      # set NA_real_ for water to match the class of the values
      
      name == 'Open water' ~ NA_real_,
      
      # use str_detect to convert multiple values to 1
      
      str_detect(name, 'Developed') ~ 1,
      
      # use str_detect to convert multiple values to 2
      
      str_detect(name, 'Forest') ~ 2,
      
      # set the default as 3 to convert the remaining categories
      
      .default = 3)) %>% 
  
  # turn the resultant object to a matrix
  
  as.matrix()

```

* <span class = "subscore">[0.1]</span> Remove `nlcd_key` from your global environment:

```{r 6_g}

# remove nlcd_key from global environment

rm(nlcd_key)

```

7\. <span class = "score">[0.5]</span> Using `rcl_nlcd` and `rasters$nlcd`:

* <span class = "subscore">[0.3]</span> Reclassify the `nlcd` raster such that it represents the developed (value = 1), forested (value = 2), and undeveloped open land (value = 3) land cover types in Washington DC;
* <span class = "subscore">[0.1]</span> Assign the object to your global environment with the name "developed_and_forested_land";

```{r 7_a-b, message = FALSE, warning = FALSE}

# reclassify the nlcd raster to developed and forested land

developed_and_forested_land <-
  
  # use function classify() to reclassify
  
  terra::classify(
    
    # the raster that need to be relassified
    
    rasters$nlcd,
    
    # the two-column reclassify matrix
    
    rcl = rcl_nlcd)

```

* <span class = "subscore">[0.1]</span> Remove `rcl_nlcd` from your global environment:

```{r}

# remove rcl_nlcd from the global environment

rm(rcl_nlcd)

```

8\. <span class = "score">[1.5]</span> Impervious surface, which represents things like roads, sidewalks, and rooftops, is often used as a proxy for urban intensity. Our goal will be to classify the impervious surface raster (`rasters$imp`) into low (< 20% impervious surface), medium (20 through < 80% impervious surface), and high intensity (>= 80% impervious surface).

* <span class = "subscore">[0.5]</span> Using the above criteria, create a reclass matrix that can be used to classify the `rasters$imp` to the numeric values 1 (low), 2 (medium), and 3 (high);
* <span class = "subscore">[0.1]</span> Assign the object to the global environment with the name `urban_rcl`;

```{r 8_a-b, message = FALSE, warning = FALSE}

# create a reclass matrix for numeric values and assign it to the certain name

urban_rcl <-
  
  # create a tibble using an easier to read row-by-row layout using tribble()
  
  tribble(
    
    # the first two columns are "from" "to" of the input values,
    # while the third column "becomes" has the new value for that range
    
    ~ from, ~ to, ~ becomes,
    0,        20,       1,
    20,       80,       2,
    80,      100,       3) %>% 
  
  # turn the resultant object to a matrix
  
  as.matrix()

```

Every time I classify a numeric raster, I first test what will happen when I supply different values for the `include.lowest` and `right` arguments. To do so, I generate a tibble of values that is sparse enough to see the whole tibble at once in the console pane. When working with percentages, I use the values 0 through 10 to represent 0 through 100%. I then add a new classified column using `cut()` and explore the behavior at the margins of each group.

* <span class = "subscore">[0.3]</span> Modify the code block below to determine the combination of `include.lowest` and `right` arguments that will generate the desired land cover classes;

```{r 8_c}

# Modify me!

tibble(values = 0:10) %>% 
  mutate(
    classes = 
      cut(values, 
          breaks = c(0, 2, 8, 10),
          
          # modified combination of the two arguments
          
          include.lowest = TRUE,
          right = FALSE))

```

* <span class = "subscore">[0.4]</span> Use `urban_rcl` to classify the `rasters$imp` 
* <span class = "subscore">[0.1]</span> Assign to your global environment with the name `urban_intensity`.

```{r 8_d-e}

# classify the impervious land raster

urban_intensity <-
  
  # use classify() to classify
  
  terra::classify(
    
    # raster needs to be classified
    
    rasters$imp,
    
    # the reclassify matrix
    
    rcl = urban_rcl,
    
    # the two arguments that decide the wanted margins as above
    
    include.lowest = TRUE,
    right = FALSE)

```

* <span class = "subscore">[0.1]</span> Remove urban_rcl and from your global environment: 

```{r 8_f}

# remove urban_rcl from global environment

rm(urban_rcl)

```


9\. <span class = "score">[2.0]</span> National Park Service land in Washington DC includes everything from traffic circles and monuments to intact patches of deciduous forest. Working with the file `nps`:

* <span class = "subscore">[0.3]</span> Filter to features where the `name` includes the string "Park&nbsp;" (with the trailing space!) or "Parkway" ;
* <span class = "subscore">[0.3]</span> Combine the geometries of parks that share the same name;
* <span class = "subscore">[0.3]</span> Add a field that represents the average canopy cover for each park;
* <span class = "subscore">[0.3]</span> Using greater than or equal to 60% canopy as your criteria, add a field called `park_type` that represents whether a park is, on average, "Forested" or "Not Forested" ;
* <span class = "subscore">[0.3]</span> Ensure that the levels of `park_type` are provided in the order: "Not Forested", "Forested";
* <span class = "subscore">[0.3]</span> Remove the `canopy` and `name` fields as parsimoniously as possible; *Hint: Notice that the `select` function isn't on the approved functions list this time?*
* <span class = "subscore">[0.1]</span> **Assign** the resultant object to your global environment with the name "nps_parks";


```{r 9_a-g, message = FALSE, warning = FALSE}

nps_parks <-
  nps %>% 
  
  # filter to features where the name includes the two specific strings
  
  filter(str_detect(name, 'Park |Parkway')) %>%
  
  # Combine the geometries of parks that share the same name, 
  # first group by name
  
  group_by(name) %>% 
  
  # and then combine the geometrics
  
  summarise() %>% 
  
  # Add a field that represents the average canopy cover for each park
  
  mutate(
    
    # create a new field
    
    canopy = 
      
      # extract canopy cover data from raster$canopy
      
      terra::extract(
        
        # the raster that to extract data from
        
        rasters$canopy,
        
        # the polygon that extract data to
        
        .,
        
        # with the concern of the average canopy cover
        
        mean, 
        
        # remove NA values
        
        na.rm = TRUE) %>% 
      
      # pull the extracted mean values to assign them to the new field
      
      pull()) %>% 
  
  # add a field to represent whether a park is on average forested
  
  mutate(
    
    # create a new field, 
    # and categorize the park type by parks' average canopy cover
    
    park_type = if_else(
      
      # if the canopy cover is greater than or equal to 60% then 'Forested'
      
      canopy >= 60,
      'Forested',
      
      # the remaining are assigned as 'Not Forested'
      
      'Not Forested') %>% 
      
      # ensure the levels are in the correct order, 'Not Forested' comes first
      
      fct_relevel(
        c('Not Forested', 'Forested'))) %>% 
  
  # remove the canopy and name fields by only transmute the remaining two fields
  
  transmute(geometry, park_type)

```

* <span class = "subscore">[0.1]</span> Remove `nps` and `rasters` from your global environment:

```{r 9_h}

# remove nps and rasters from the global environment

rm(nps, rasters)

```


<br>
10\. <span class = "score">[1.5]</span>. Generate a tmap that includes each of the layers that you've developed above (see lifelines if you were not able to develop one of the files).

*  <span class = "subscore">[0.25]</span> Use (*only*) OpenStreetMap and Esri.WorldImagery as background layers;
*  <span class = "subscore">[0.25]</span> Ensure that categorical raster values are not plotted as numeric;
*  <span class = "subscore">[0.25]</span> Use a similar color palette to represent forest across map layers initiated by `tm_shape()`;
*  <span class = "subscore">[0.5]</span> Ensure meaningful layer and legend title names for each layer;
*  <span class = "subscore">[0.25]</span> For categorical raster layers, ensure that the levels are given meaningful labels.

```{r question_10, message = FALSE, warning = FALSE}

tm_basemap(
  
  # use the two specified background layers
  
  c('OpenStreetMap',
    'Esri.WorldImagery')) +
  
  # Income
  
  tm_shape(
    
    # the raster's name
    
    income_dc,
    
    # name the layer
    
    name = 'Income') +
  tm_raster(
    
    # name the layer legend
    
    title = 'Income (Dollars)',
    
    # change the default orange tone to distinguish from other layers' palettes
    
    palette = 'Blues') +
  
  # DC parks
  
  tm_shape(
    
    # sf object's name
    
    nps_parks,
    
    # name the layer
    
    name = 'DC parks') +
  tm_polygons(
    
    # name the layer legend
    
    title = 'Forest coverage',
    
    # specify 'park_type' to be the colors
    
    col = 'park_type',
    
    # assign an appropriate color to each category, green to 'forested'
    
    palette = 
      c('#ffffbf', '#91cf60')) +
  
  # Developed and Forested Land
  
  tm_shape(
    
    # name of the raster
    
    developed_and_forested_land,
    
    # name the layer
    
    name = 'Land Cover') +
  tm_raster(
    
    # name the layer's legend
    
    title = 'Land cover',
    
    # assign its colors to the field 'nlcd'
    
    col = 'nlcd',
    
    # assign a meaningful and pleasant palette, the same green to forest
    
    palette = 
      c('#fc8d62', '#91cf60', '#bdbdbd'),
    
    # give each category meaningful labels
    
    labels = 
      c('Developed', 'Forest', 'Undeveloped Openland'),
    
    # ensure this layer been plotted as a categorical layer
    
    style = 'cat') +
  
  # urban intensity
  
  tm_shape(
    
    # name of the raster
    
    urban_intensity,
    
    # give name to the layer
    
    name = 'Urban Intensity') +
  tm_raster(
    
    # name the layer's legend
    
    title = 'Impervious surface intensity',
    
    # assign pleasant and distinguishable palette
    
    palette = 
      c('#fde0dd', '#fa9fb5', '#c51b8a'),
    
    # ensure this raster to be plotted as categorical
    
    style = 'cat',
    
    # assign a label to each level
    
    labels = 
      c('Low', 'Medium', 'High')) +
  
  # NPS parks
  
  tm_shape(
    
    # name of the sf object
    
    nps_parks,
    
    # name the layer
    
    name = 'National Park Service parks') +
  
  tm_polygons(
    
    # name the layer's legend
    
    title = 'Park type',
    
    # assign "park_type" to be shown as the color
    
    col = 'park_type',
    
    # assign meaningful palette, and the same green to 'Forested'
    
    palette = 
      c('#ffffbf', '#91cf60'))

```
</div>

**Extra credit** <span class = "score">[0.25]</span>: You most likely have a duplicated legend. Check out the help file for `tm_polygons()` and remove one of the legends.

Now that you've completed the code, take a look at the maps you've created. Does DC do a good job of providing forested spaces across all income levels in the city? In my opinion, a case could be made for some success despite socioeconomic clustering *and* much more work to do because of socioeconomic clustering!

If you're guessing that we'll be exploring these patterns a bit further next week ...
<hr>

<script>
var acc = document.getElementsByClassName("accordion");
var i;

for (i = 0; i < acc.length; i++) {
  acc[i].addEventListener("click", function() {
    this.classList.toggle("active");
    var panel = this.nextElementSibling;
    if (panel.style.display === "block") {
      panel.style.display = "none";
    } else {
      panel.style.display = "block";
    }
  });
}
</script>